local a local b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u={function()local b,c,d=a(1)local e return(function(...)local f,g=d(c.PubTypes),d(c.Utility.restrictRead)export type StateObject<T> =f.StateObject<T>export type CanBeState<T> =f.CanBeState<T>export type Symbol=f.Symbol export type Value<T> =f.Value<T>export type Computed<T> =f.Computed<T>export type ForPairs<KO,VO> =f.ForPairs<KO,VO>export type ForKeys<KI,KO> =f.ForKeys<KI,KO>export type ForValues<VI,VO> =f.ForKeys<VI,VO>export type Observer=f.Observer export type Tween<T> =f.Tween<T>export type Spring<T> =f.Spring<T>type Fusion={version:f.Version,New:(className:string)->(propertyTable:f.PropertyTable)->Instance,Hydrate:(target:Instance)->(propertyTable:f.PropertyTable)->Instance,Ref:f.SpecialKey,Cleanup:f.SpecialKey,Children:f.SpecialKey,Out:f.SpecialKey,OnEvent:(eventName:string)->f.SpecialKey,OnChange:(propertyName:string)->f.SpecialKey,Value:<T>(initialValue:T)->Value<T>,Computed:<T>(callback:()->T,destructor:((T)->())?)->Computed<T>,ForPairs:<KI,VI,KO,VO,M>(inputTable:CanBeState<{[KI]:VI}>,processor:(KI,VI)->(KO,VO,M?),destructor:((KO,VO,M?)->())?)->ForPairs<KO,VO>,ForKeys:<KI,KO,M>(inputTable:CanBeState<{[KI]:any}>,processor:(KI)->(KO,M?),destructor:((KO,M?)->())?)->ForKeys<KO,any>,ForValues:<VI,VO,M>(inputTable:CanBeState<{[any]:VI}>,processor:(VI)->(VO,M?),destructor:((VO,M?)->())?)->ForValues<any,VO>,Observer:(watchedState:StateObject<any>)->Observer,Tween:<T>(goalState:StateObject<T>,tweenInfo:TweenInfo?)->Tween<T>,Spring:<T>(goalState:StateObject<T>,speed:number?,damping:number?)->Spring<T>,cleanup:(...any)->(),doNothing:(...any)->()}return g('Fusion',{version={major=0,minor=2,isRelease=true},New=d(c.Instances.New),Hydrate=d(c.Instances.Hydrate),Ref=d(c.Instances.Ref),Out=d(c.Instances.Out),Cleanup=d(c.Instances.Cleanup),Children=d(c.Instances.Children),OnEvent=d(c.Instances.OnEvent),OnChange=d(c.Instances.OnChange),Value=d(c.State.Value),Computed=d(c.State.Computed),ForPairs=d(c.State.ForPairs),ForKeys=d(c.State.ForKeys),ForValues=d(c.State.ForValues),Observer=d(c.State.Observer),Tween=d(c.Animation.Tween),Spring=d(c.Animation.Spring),cleanup=d(c.Utility.cleanup),doNothing=d(c.Utility.doNothing)})::Fusion end)()end,[3]=function()local b,c,d=a(3)local e return(function(...)local f=function(f:any)local g=typeof(f)if g=='table'and typeof(f.type)=='string'then return f.type else return g end end return f end)()end,[4]=function()local b,c,d=a(4)local e return(function(...)local f=c.Parent.Parent local g=d(f.Logging.logError)type table={[any]:any}local h=function(h:string,i:table)local j=getmetatable(i::any)if j==nil then j={}setmetatable(i,j)end function j.__index(k,l)g('strictReadError',nil,tostring(l),h)end return i end return h end)()end,[5]=function()local b,c,d=a(5)local e return(function(...)local f=function(f:any)return typeof(f)=='Instance'end return f end)()end,[6]=function()local b,c,d=a(6)local e return(function(...)local f=function(f:any,g:any)if typeof(f)=='table'then return false else return f==g end end return f end)()end,[7]=function()local b,c,d=a(7)local e return(function(...)local f=function(...)end return f end)()end,[8]=function()local b,c,d=a(8)local e return(function(...)local function f(g:any)local h=typeof(g)if h=='Instance'then g:Destroy()elseif h=='RBXScriptConnection'then g:Disconnect()elseif h=='function'then g()elseif h=='table'then if typeof(g.destroy)=='function'then g:destroy()elseif typeof(g.Destroy)=='function'then g:Destroy()elseif g[1]~=nil then for i,j in ipairs(g)do f(j)end end end end local g=function(...)for g=1,select('#',...)do f(select(g,...))end end return g end)()end,[9]=function()local b,c,d=a(9)local e return(function(...)local f=c.Parent.Parent local g=d(f.Types)return{type='Symbol',name='None'}::g.None end)()end,[10]=function()local b,c,d=a(10)local e return(function(...)local f=c.Parent local g=d(f.PubTypes)type Set<T> ={[T]:any}export type None=g.Symbol&{}export type Error={type:string,raw:string,message:string,trace:string}export type State<T> =g.Value<T>&{_value:T}export type Computed<T> =g.Computed<T>&{_oldDependencySet:Set<g.Dependency>,_callback:()->T,_value:T}export type ForPairs<KI,VI,KO,VO,M> =g.ForPairs<KO,VO>&{_oldDependencySet:Set<g.Dependency>,_processor:(KI,VI)->(KO,VO),_destructor:(VO,M?)->(),_inputIsState:boolean,_inputTable:g.CanBeState<{[KI]:VI}>,_oldInputTable:{[KI]:VI},_outputTable:{[KO]:VO},_oldOutputTable:{[KO]:VO},_keyIOMap:{[KI]:KO},_meta:{[KO]:M?},_keyData:{[KI]:{dependencySet:Set<g.Dependency>,oldDependencySet:Set<g.Dependency>,dependencyValues:{[g.Dependency]:any}}}}export type ForKeys<KI,KO,M> =g.ForKeys<KO,any>&{_oldDependencySet:Set<g.Dependency>,_processor:(KI)->KO,_destructor:(KO,M?)->(),_inputIsState:boolean,_inputTable:g.CanBeState<{[KI]:KO}>,_oldInputTable:{[KI]:KO},_outputTable:{[KO]:any},_keyOIMap:{[KO]:KI},_meta:{[KO]:M?},_keyData:{[KI]:{dependencySet:Set<g.Dependency>,oldDependencySet:Set<g.Dependency>,dependencyValues:{[g.Dependency]:any}}}}export type ForValues<VI,VO,M> =g.ForValues<any,VO>&{_oldDependencySet:Set<g.Dependency>,_processor:(VI)->VO,_destructor:(VO,M?)->(),_inputIsState:boolean,_inputTable:g.CanBeState<{[VI]:VO}>,_outputTable:{[any]:VI},_valueCache:{[VO]:any},_oldValueCache:{[VO]:any},_meta:{[VO]:M?},_valueData:{[VI]:{dependencySet:Set<g.Dependency>,oldDependencySet:Set<g.Dependency>,dependencyValues:{[g.Dependency]:any}}}}export type Tween<T> =g.Tween<T>&{_goalState:State<T>,_tweenInfo:TweenInfo,_prevValue:T,_nextValue:T,_currentValue:T,_currentTweenInfo:TweenInfo,_currentTweenDuration:number,_currentTweenStartTime:number,_currentlyAnimating:boolean}export type Spring<T> =g.Spring<T>&{_speed:g.CanBeState<number>,_speedIsState:boolean,_lastSpeed:number,_damping:g.CanBeState<number>,_dampingIsState:boolean,_lastDamping:number,_goalState:State<T>,_goalValue:T,_currentType:string,_currentValue:T,_springPositions:{number},_springGoals:{number},_springVelocities:{number}}export type Observer=g.Observer&{_changeListeners:Set<()->()>,_numChangeListeners:number}return nil end)()end,[12]=function()local b,c,d=a(12)local e return(function(...)local f=c.Parent.Parent local g,h=d(f.PubTypes),d(f.Utility.xtypeof)local i=function(i:g.CanBeState<T>,j:boolean?)return if h(i)=='State'then(i::g.StateObject<T>):get(j)else i::T end return i end)()end,[13]=function()local b,c,d=a(13)local e return(function(...)local f=c.Parent.Parent local g,h,i,j,k,l=d(f.Types),d(f.Dependencies.initDependency),d(f.Utility.isSimilar),d(f.Dependencies.updateAll),d(f.Dependencies.useDependency),{}local m,n={__index=l},{__mode='k'}function l.get(o,p:boolean?):any if p~=false then k(o)end return o._value end function l.set(o,p:any,q:boolean?)local r=o._value if q or not i(r,p)then o._value=p j(o)end end local o=function(o:T)local p=setmetatable({type='State',kind='Value',dependentSet=setmetatable({},n),_value=o},m)h(p)return p end return o end)()end,[14]=function()local b,c,d=a(14)local e return(function(...)local f=c.Parent.Parent local g,h,i=d(f.PubTypes),d(f.Types),d(f.Dependencies.initDependency)type Set<T> ={[T]:any}local j={}local k,l:Set<h.Observer> ={__index=j},{}function j.update(m):boolean for n,o in pairs(m._changeListeners)do task.spawn(o)end return false end function j.onChange(m,n:()->()):()->()local o={}m._numChangeListeners+=1 m._changeListeners[o]=n l[m]=true local p=false return function()if p then return end p=true m._changeListeners[o]=nil m._numChangeListeners-=1 if m._numChangeListeners==0 then l[m]=nil end end end local m=function(m:g.Value<any>)local n=setmetatable({type='State',kind='Observer',dependencySet={[m]=true},dependentSet={},_changeListeners={},_numChangeListeners=0},k)i(n)m.dependentSet[n]=true return n end return m end)()end,[15]=function()local b,c,d=a(15)local e return(function(...)local f=c.Parent.Parent local g,h,i,j,k,l,m,n,o,p,q=d(f.PubTypes),d(f.Types),d(f.Dependencies.captureDependencies),d(f.Utility.cleanup),d(f.Dependencies.initDependency),d(f.Logging.logErrorNonFatal),d(f.Logging.logWarn),d(f.Utility.needsDestruction),d(f.Logging.parseError),d(f.Dependencies.useDependency),{}local r,s={__index=q},{__mode='k'}function q.get(t,u:boolean?):any if u~=false then p(t)end return t._outputTable end function q.update(t):boolean local u=t._inputIsState local v,w,x=if u then t._inputTable:get(false)else t._inputTable,{},false t._oldValueCache,t._valueCache=t._valueCache,t._oldValueCache local y,z=t._valueCache,t._oldValueCache table.clear(y)for A in pairs(t.dependencySet)do A.dependentSet[t]=nil end t._oldDependencySet,t.dependencySet=t.dependencySet,t._oldDependencySet table.clear(t.dependencySet)if u then t._inputTable.dependentSet[t]=true t.dependencySet[t._inputTable]=true end for A,B in pairs(v)do local C=z[B]local D,E,F,G=(C==nil)if type(C)=='table'and#C>0 then local H=table.remove(C,#C)E=H.value F=H.valueData G=H.meta if#C<=0 then z[B]=nil end elseif C~=nil then z[B]=nil D=true end if F==nil then F={dependencySet=setmetatable({},s),oldDependencySet=setmetatable({},s),dependencyValues=setmetatable({},s)}end if D==false then for H,I in pairs(F.dependencyValues)do if I~=H:get(false)then D=true break end end end if D then F.oldDependencySet,F.dependencySet=F.dependencySet,F.oldDependencySet table.clear(F.dependencySet)local H,I,J=i(F.dependencySet,t._processor,B)if H then if t._destructor==nil and(n(I)or n(J))then m'destructorNeededForValues'end if E~=nil then local K,L=xpcall(t._destructor or j,o,E,G)if not K then l('forValuesDestructorError',L)end end E=I G=J x=true else F.oldDependencySet,F.dependencySet=F.dependencySet,F.oldDependencySet l('forValuesProcessorError',I)end end local H=y[B]if H==nil then H={}y[B]=H end table.insert(H,{value=E,valueData=F,meta=G})w[A]=E for I in pairs(F.dependencySet)do F.dependencyValues[I]=I:get(false)t.dependencySet[I]=true I.dependentSet[t]=true end end for A,B in pairs(z)do for C,D in ipairs(B)do local E,F=D.value,D.meta local G,H=xpcall(t._destructor or j,o,E,F)if not G then l('forValuesDestructorError',H)end x=true end table.clear(B)end t._outputTable=w return x end local t=function(t:g.CanBeState<{[any]:VI}>,u:(VI)->(VO,M?),v:((VO,M?)->())?)local w=t.type=='State'and typeof(t.get)=='function'local x=setmetatable({type='State',kind='ForValues',dependencySet={},dependentSet=setmetatable({},s),_oldDependencySet={},_processor=u,_destructor=v,_inputIsState=w,_inputTable=t,_outputTable={},_valueCache={},_oldValueCache={}},r)k(x)x:update()return x end return t end)()end,[16]=function()local b,c,d=a(16)local e return(function(...)local f=c.Parent.Parent local g,h,i,j,k,l,m,n,o,p,q,r=d(f.PubTypes),d(f.Types),d(f.Dependencies.captureDependencies),d(f.Utility.cleanup),d(f.Dependencies.initDependency),d(f.Logging.logError),d(f.Logging.logErrorNonFatal),d(f.Logging.logWarn),d(f.Utility.needsDestruction),d(f.Logging.parseError),d(f.Dependencies.useDependency),{}local s,t={__index=r},{__mode='k'}function r.get(u,v:boolean?):any if v~=false then q(u)end return u._outputTable end function r.update(u):boolean local v=u._inputIsState local w,x,y,z,A=if v then u._inputTable:get(false)else u._inputTable,u._oldInputTable,u._keyIOMap,u._meta,false for B in pairs(u.dependencySet)do B.dependentSet[u]=nil end u._oldDependencySet,u.dependencySet=u.dependencySet,u._oldDependencySet table.clear(u.dependencySet)if v then u._inputTable.dependentSet[u]=true u.dependencySet[u._inputTable]=true end u._oldOutputTable,u._outputTable=u._outputTable,u._oldOutputTable local B,C=u._oldOutputTable,u._outputTable table.clear(C)for D,E in pairs(w)do local F=u._keyData[D]if F==nil then F={dependencySet=setmetatable({},t),oldDependencySet=setmetatable({},t),dependencyValues=setmetatable({},t)}u._keyData[D]=F end local G=x[D]~=E if G==false then for H,I in pairs(F.dependencyValues)do if I~=H:get(false)then G=true break end end end if G then F.oldDependencySet,F.dependencySet=F.dependencySet,F.oldDependencySet table.clear(F.dependencySet)local H,I,J,K=i(F.dependencySet,u._processor,D,E)if H then if u._destructor==nil and(o(I)or o(J)or o(K))then n'destructorNeededForPairs'end if C[I]~=nil then local L,M for N,O in pairs(y)do if O==I then M=w[N]if M~=nil then L=N break end end end if L~=nil then l('forPairsKeyCollision',nil,tostring(I),tostring(L),tostring(M),tostring(D),tostring(E))end end local L=B[I]if L~=J then local M=z[I]if L~=nil then local N,O=xpcall(u._destructor or j,p,I,L,M)if not N then m('forPairsDestructorError',O)end end B[I]=nil end x[D]=E y[D]=I z[I]=K C[I]=J A=true else F.oldDependencySet,F.dependencySet=F.dependencySet,F.oldDependencySet m('forPairsProcessorError',I)end else local H=y[D]if C[H]~=nil then local I,J for K,L in pairs(y)do if H==L then J=w[K]if J~=nil then I=K break end end end if I~=nil then l('forPairsKeyCollision',nil,tostring(H),tostring(I),tostring(J),tostring(D),tostring(E))end end C[H]=B[H]end for H in pairs(F.dependencySet)do F.dependencyValues[H]=H:get(false)u.dependencySet[H]=true H.dependentSet[u]=true end end for D,E in pairs(B)do if C[D]~=E then local F=z[D]if E~=nil then local G,H=xpcall(u._destructor or j,p,D,E,F)if not G then m('forPairsDestructorError',H)end end if C[D]==nil then z[D]=nil u._keyData[D]=nil end A=true end end for D in pairs(x)do if w[D]==nil then x[D]=nil y[D]=nil end end return A end local u=function(u:g.CanBeState<{[KI]:VI}>,v:(KI,VI)->(KO,VO,M?),w:((KO,VO,M?)->())?)local x=u.type=='State'and typeof(u.get)=='function'local y=setmetatable({type='State',kind='ForPairs',dependencySet={},dependentSet=setmetatable({},t),_oldDependencySet={},_processor=v,_destructor=w,_inputIsState=x,_inputTable=u,_oldInputTable={},_outputTable={},_oldOutputTable={},_keyIOMap={},_keyData={},_meta={}},s)k(y)y:update()return y end return u end)()end,[17]=function()local b,c,d=a(17)local e return(function(...)local f=c.Parent.Parent local g,h,i,j,k,l,m,n,o,p,q,r=d(f.PubTypes),d(f.Types),d(f.Dependencies.captureDependencies),d(f.Utility.cleanup),d(f.Dependencies.initDependency),d(f.Logging.logError),d(f.Logging.logErrorNonFatal),d(f.Logging.logWarn),d(f.Utility.needsDestruction),d(f.Logging.parseError),d(f.Dependencies.useDependency),{}local s,t={__index=r},{__mode='k'}function r.get(u,v:boolean?):any if v~=false then q(u)end return u._outputTable end function r.update(u):boolean local v=u._inputIsState local w,x,y,z,A,B,C=if v then u._inputTable:get(false)else u._inputTable,u._oldInputTable,u._outputTable,u._keyOIMap,u._keyIOMap,u._meta,false for D in pairs(u.dependencySet)do D.dependentSet[u]=nil end u._oldDependencySet,u.dependencySet=u.dependencySet,u._oldDependencySet table.clear(u.dependencySet)if v then u._inputTable.dependentSet[u]=true u.dependencySet[u._inputTable]=true end for D,E in pairs(w)do local F=u._keyData[D]if F==nil then F={dependencySet=setmetatable({},t),oldDependencySet=setmetatable({},t),dependencyValues=setmetatable({},t)}u._keyData[D]=F end local G=x[D]==nil if G==false then for H,I in pairs(F.dependencyValues)do if I~=H:get(false)then G=true break end end end if G then F.oldDependencySet,F.dependencySet=F.dependencySet,F.oldDependencySet table.clear(F.dependencySet)local H,I,J=i(F.dependencySet,u._processor,D)if H then if u._destructor==nil and(o(I)or o(J))then n'destructorNeededForKeys'end local K,L=z[I],A[D]if K~=D and w[K]~=nil then l('forKeysKeyCollision',nil,tostring(I),tostring(K),tostring(I))end if L~=I and z[L]==D then local M=B[L]local N,O=xpcall(u._destructor or j,p,L,M)if not N then m('forKeysDestructorError',O)end z[L]=nil y[L]=nil B[L]=nil end x[D]=E B[I]=J z[I]=D A[D]=I y[I]=E C=true else F.oldDependencySet,F.dependencySet=F.dependencySet,F.oldDependencySet m('forKeysProcessorError',I)end end for H in pairs(F.dependencySet)do F.dependencyValues[H]=H:get(false)u.dependencySet[H]=true H.dependentSet[u]=true end end for D,E in pairs(z)do if w[E]==nil then local F=B[D]local G,H=xpcall(u._destructor or j,p,D,F)if not G then m('forKeysDestructorError',H)end x[E]=nil B[D]=nil z[D]=nil A[E]=nil y[D]=nil u._keyData[E]=nil C=true end end return C end local u=function(u:g.CanBeState<{[KI]:any}>,v:(KI)->(KO,M?),w:((KO,M?)->())?)local x=u.type=='State'and typeof(u.get)=='function'local y=setmetatable({type='State',kind='ForKeys',dependencySet={},dependentSet=setmetatable({},t),_oldDependencySet={},_processor=v,_destructor=w,_inputIsState=x,_inputTable=u,_oldInputTable={},_outputTable={},_keyOIMap={},_keyIOMap={},_keyData={},_meta={}},s)k(y)y:update()return y end return u end)()end,[18]=function()local b,c,d=a(18)local e return(function(...)local f=c.Parent.Parent local g,h,i,j,k,l,m,n,o=d(f.Types),d(f.Dependencies.captureDependencies),d(f.Dependencies.initDependency),d(f.Utility.isSimilar),d(f.Logging.logErrorNonFatal),d(f.Logging.logWarn),d(f.Utility.needsDestruction),d(f.Dependencies.useDependency),{}local p,q={__index=o},{__mode='k'}function o.get(r,s:boolean?):any if s~=false then n(r)end return r._value end function o.update(r):boolean for s in pairs(r.dependencySet)do s.dependentSet[r]=nil end r._oldDependencySet,r.dependencySet=r.dependencySet,r._oldDependencySet table.clear(r.dependencySet)local s,t,u=h(r.dependencySet,r._processor)if s then if r._destructor==nil and m(t)then l'destructorNeededComputed'end if u~=nil then l'multiReturnComputed'end local v=r._value local w=j(v,t)if r._destructor~=nil then r._destructor(v)end r._value=t for x in pairs(r.dependencySet)do x.dependentSet[r]=true end return not w else k('computedCallbackError',t)r._oldDependencySet,r.dependencySet=r.dependencySet,r._oldDependencySet for v in pairs(r.dependencySet)do v.dependentSet[r]=true end return false end end local r=function(r:()->T,s:((T)->())?)local t=setmetatable({type='State',kind='Computed',dependencySet={},dependentSet=setmetatable({},q),_oldDependencySet={},_processor=r,_destructor=s,_value=nil},p)i(t)t:update()return t end return r end)()end,[19]=function()local b,c,d=a(19)local e return(function(...)type Set<T> ={[T]:any}export type Symbol={type:string,name:string}export type Animatable=number|CFrame|Color3|ColorSequenceKeypoint|DateTime|NumberRange|NumberSequenceKeypoint|PhysicalProperties|Ray|Rect|Region3|Region3int16|UDim|UDim2|Vector2|Vector2int16|Vector3|Vector3int16 export type Task=Instance|RBXScriptConnection|(()->())|{destroy:(any)->()}|{Destroy:(any)->()}|{Task}export type Version={major:number,minor:number,isRelease:boolean}export type Dependency={dependentSet:Set<Dependent>}export type Dependent={update:(Dependent)->boolean,dependencySet:Set<Dependency>}export type StateObject<T> =Dependency&{type:string,kind:string,get:(StateObject<T>,asDependency:boolean?)->T}export type CanBeState<T> =StateObject<T>|T export type Value<T> =StateObject<T>&{set:(Value<T>,newValue:any,force:boolean?)->()}export type Computed<T> =StateObject<T>&Dependent&{}export type ForPairs<KO,VO> =StateObject<{[KO]:VO}>&Dependent&{}export type ForKeys<KO,V> =StateObject<{[KO]:V}>&Dependent&{}export type ForValues<K,VO> =StateObject<{[K]:VO}>&Dependent&{}export type Tween<T> =StateObject<T>&Dependent&{}export type Spring<T> =StateObject<T>&Dependent&{}export type Observer=Dependent&{onChange:(Observer,callback:()->())->()->()}export type SpecialKey={type:string,kind:string,stage:string,apply:(SpecialKey,value:any,applyTo:Instance,cleanupTasks:{Task})->()}export type Children=Instance|StateObject<Children>|{[any]:Children}export type PropertyTable={[(string|SpecialKey)]:any}return nil end)()end,[21]=function()local b,c,d=a(21)local e return(function(...)local f=c.Parent.Parent local g,h=d(f.Types),function(g:string)return{type='Error',raw=g,message=g:gsub('^.+:%d+:%s*',''),trace=debug.traceback(nil,2)}end return h end)()end,[22]=function()local b,c,d=a(22)local e return(function(...)return{cannotAssignProperty="The class type '%s' has no assignable property '%s'.",cannotConnectChange="The %s class doesn't have a property called '%s'.",cannotConnectEvent="The %s class doesn't have an event called '%s'.",cannotCreateClass="Can't create a new instance of class '%s'.",computedCallbackError='Computed callback error: ERROR_MESSAGE',destructorNeededValue=[[To save instances into Values, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.]],destructorNeededComputed=[[To return instances from Computeds, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.]],multiReturnComputed=[[Returning multiple values from Computeds is discouraged, as behaviour will change soon - see discussion #189 on GitHub.]],destructorNeededForKeys=[[To return instances from ForKeys, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.]],destructorNeededForValues=[[To return instances from ForValues, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.]],destructorNeededForPairs=[[To return instances from ForPairs, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.]],duplicatePropertyKey='',forKeysProcessorError='ForKeys callback error: ERROR_MESSAGE',forKeysKeyCollision=[[ForKeys should only write to output key '%s' once when processing key changes, but it wrote to it twice. Previously input key: '%s'; New input key: '%s']],forKeysDestructorError='ForKeys destructor error: ERROR_MESSAGE',forPairsDestructorError='ForPairs destructor error: ERROR_MESSAGE',forPairsKeyCollision=[[ForPairs should only write to output key '%s' once when processing key changes, but it wrote to it twice. Previous input pair: '[%s] = %s'; New input pair: '[%s] = %s']],forPairsProcessorError='ForPairs callback error: ERROR_MESSAGE',forValuesProcessorError='ForValues callback error: ERROR_MESSAGE',forValuesDestructorError='ForValues destructor error: ERROR_MESSAGE',invalidChangeHandler=[[The change handler for the '%s' property must be a function.]],invalidEventHandler="The handler for the '%s' event must be a function.",invalidPropertyType="'%s.%s' expected a '%s' type, but got a '%s' type.",invalidRefType='Instance refs must be Value objects.',invalidOutType='[Out] properties must be given Value objects.',invalidOutProperty="The %s class doesn't have a property called '%s'.",invalidSpringDamping=[[The damping ratio for a spring must be >= 0. (damping was %.2f)]],invalidSpringSpeed='The speed of a spring must be >= 0. (speed was %.2f)',mistypedSpringDamping='The damping ratio for a spring must be a number. (got a %s)',mistypedSpringSpeed='The speed of a spring must be a number. (got a %s)',mistypedTweenInfo='The tween info of a tween must be a TweenInfo. (got a %s)',springTypeMismatch="The type '%s' doesn't match the spring's type '%s'.",strictReadError="'%s' is not a valid member of '%s'.",unknownMessage='Unknown error: ERROR_MESSAGE',unrecognisedChildType="'%s' type children aren't accepted by `[Children]`.",unrecognisedPropertyKey="'%s' keys aren't accepted in property tables.",unrecognisedPropertyStage=[['%s' isn't a valid stage for a special key to be applied at.]]}end)()end,[23]=function()local b,c,d=a(23)local e return(function(...)local f=c.Parent.Parent local g=d(f.Logging.messages)local h=function(h,...)local i:string if g[h]~=nil then i=g[h]else h='unknownMessage'i=g[h]end warn(string.format('[Fusion] '..i..'\n(ID: '..h..')',...))end return h end)()end,[24]=function()local b,c,d=a(24)local e return(function(...)local f=c.Parent.Parent local g,h=d(f.Types),d(f.Logging.messages)local i=function(i:string,j:g.Error?,...)local k:string if h[i]~=nil then k=h[i]else i='unknownMessage'k=h[i]end local l if j==nil then l=string.format('[Fusion] '..k..'\n(ID: '..i..')',...)else k=k:gsub('ERROR_MESSAGE',j.message)l=string.format('[Fusion] '..k..'\n(ID: '..i..')\n---- Stack trace ----\n'..j.trace,...)end task.spawn(function(...)error(l:gsub('\n','\n    '),0)end,...)end return i end)()end,[25]=function()local b,c,d=a(25)local e return(function(...)local f=c.Parent.Parent local g,h=d(f.Types),d(f.Logging.messages)local i=function(i:string,j:g.Error?,...)local k:string if h[i]~=nil then k=h[i]else i='unknownMessage'k=h[i]end local l if j==nil then l=string.format('[Fusion] '..k..'\n(ID: '..i..')',...)else k=k:gsub('ERROR_MESSAGE',j.message)l=string.format('[Fusion] '..k..'\n(ID: '..i..')\n---- Stack trace ----\n'..j.trace,...)end error(l:gsub('\n','\n    '),0)end return i end)()end,[27]=function()local b,c,d=a(27)local e return(function(...)return{ScreenGui={ResetOnSpawn=false,ZIndexBehavior=Enum.ZIndexBehavior.Sibling},BillboardGui={ResetOnSpawn=false,ZIndexBehavior=Enum.ZIndexBehavior.Sibling},SurfaceGui={ResetOnSpawn=false,ZIndexBehavior=Enum.ZIndexBehavior.Sibling,SizingMode=Enum.SurfaceGuiSizingMode.PixelsPerStud,PixelsPerStud=50},Frame={BackgroundColor3=Color3.new(1,1,1),BorderColor3=Color3.new(0,0,0),BorderSizePixel=0},ScrollingFrame={BackgroundColor3=Color3.new(1,1,1),BorderColor3=Color3.new(0,0,0),BorderSizePixel=0,ScrollBarImageColor3=Color3.new(0,0,0)},TextLabel={BackgroundColor3=Color3.new(1,1,1),BorderColor3=Color3.new(0,0,0),BorderSizePixel=0,Font=Enum.Font.SourceSans,Text='',TextColor3=Color3.new(0,0,0),TextSize=14},TextButton={BackgroundColor3=Color3.new(1,1,1),BorderColor3=Color3.new(0,0,0),BorderSizePixel=0,AutoButtonColor=false,Font=Enum.Font.SourceSans,Text='',TextColor3=Color3.new(0,0,0),TextSize=14},TextBox={BackgroundColor3=Color3.new(1,1,1),BorderColor3=Color3.new(0,0,0),BorderSizePixel=0,ClearTextOnFocus=false,Font=Enum.Font.SourceSans,Text='',TextColor3=Color3.new(0,0,0),TextSize=14},ImageLabel={BackgroundColor3=Color3.new(1,1,1),BorderColor3=Color3.new(0,0,0),BorderSizePixel=0},ImageButton={BackgroundColor3=Color3.new(1,1,1),BorderColor3=Color3.new(0,0,0),BorderSizePixel=0,AutoButtonColor=false},ViewportFrame={BackgroundColor3=Color3.new(1,1,1),BorderColor3=Color3.new(0,0,0),BorderSizePixel=0},VideoFrame={BackgroundColor3=Color3.new(1,1,1),BorderColor3=Color3.new(0,0,0),BorderSizePixel=0},CanvasGroup={BackgroundColor3=Color3.new(1,1,1),BorderColor3=Color3.new(0,0,0),BorderSizePixel=0}}end)()end,[28]=function()local b,c,d=a(28)local e return(function(...)local f=c.Parent.Parent local g,h,i,j,k,l,m=d(f.State.Observer),d(f.PubTypes),d(f.Utility.cleanup),d(f.Logging.logError),d(f.Utility.xtypeof),function(g:Instance,h:string,i:any)(g::any)[h]=i end,function(g:Instance,h:string)(g::any)[h]=(g::any)[h]end local n=function(n:Instance,o:string,p:any)if not pcall(l,n,o,p)then if not pcall(m,n,o)then if n==nil then j('setPropertyNilRef',nil,o,tostring(p))else j('cannotAssignProperty',nil,n.ClassName,o)end else local q,r=typeof(p),typeof((n::any)[o])j('invalidPropertyType',nil,n.ClassName,o,r,q)end end end local o=function(o:Instance,p:string,q:h.CanBeState<any>,r:{h.Task})if k(q)=='State'then local s=false local t=function()if not s then s=true task.defer(function()s=false n(o,p,q:get(false))end)end end n(o,p,q:get(false))table.insert(r,g(q::any):onChange(t))else n(o,p,q)end end local p=function(p:h.PropertyTable,q:Instance)local r,s={self={}::{[h.SpecialKey]:any},descendants={}::{[h.SpecialKey]:any},ancestor={}::{[h.SpecialKey]:any},observer={}::{[h.SpecialKey]:any}},{}for t,u in pairs(p)do local v=k(t)if v=='string'then if t~='Parent'then o(q,t::string,u,s)end elseif v=='SpecialKey'then local w=(t::h.SpecialKey).stage local x=r[w]if x==nil then j('unrecognisedPropertyStage',nil,w)else x[t]=u end else j('unrecognisedPropertyKey',nil,k(t))end end for t,u in pairs(r.self)do t:apply(u,q,s)end for t,u in pairs(r.descendants)do t:apply(u,q,s)end if p.Parent~=nil then o(q,'Parent',p.Parent,s)end for t,u in pairs(r.ancestor)do t:apply(u,q,s)end for t,u in pairs(r.observer)do t:apply(u,q,s)end q.Destroying:Connect(function()i(s)end)end return p end)()end,[29]=function()local b,c,d=a(29)local e return(function(...)local f=c.Parent.Parent local g,h,i,j=d(f.PubTypes),d(f.Logging.logError),d(f.Utility.xtypeof),{}j.type='SpecialKey'j.kind='Ref'j.stage='observer'function j.apply(k,l:any,m:Instance,n:{g.Task})if i(l)~='State'or l.kind~='Value'then h'invalidRefType'else l:set(m)table.insert(n,function()l:set(nil)end)end end return j end)()end,[30]=function()local b,c,d=a(30)local e return(function(...)local f=c.Parent.Parent local g,h,i=d(f.PubTypes),d(f.Logging.logError),d(f.Utility.xtypeof)local j=function(j:string)local k={}k.type='SpecialKey'k.kind='Out'k.stage='observer'function k.apply(l,m:any,n:Instance,o:{g.Task})local p,q=pcall(n.GetPropertyChangedSignal,n,j)if not p then h('invalidOutProperty',nil,n.ClassName,j)elseif i(m)~='State'or m.kind~='Value'then h'invalidOutType'else m:set((n::any)[j])table.insert(o,q:Connect(function()m:set((n::any)[j])end))table.insert(o,function()m:set(nil)end)end end return k end return j end)()end,[31]=function()local b,c,d=a(31)local e return(function(...)local f=c.Parent.Parent local g,h,i=d(f.PubTypes),d(f.Logging.logError),function(g:Instance,h:string)return(g::any)[h]end local j=function(j:string)local k={}k.type='SpecialKey'k.kind='OnEvent'k.stage='observer'function k.apply(l,m:any,n:Instance,o:{g.Task})local p,q=pcall(i,n,j)if not p or typeof(q)~='RBXScriptSignal'then h('cannotConnectEvent',nil,n.ClassName,j)elseif typeof(m)~='function'then h('invalidEventHandler',nil,j)else table.insert(o,q:Connect(m))end end return k end return j end)()end,[32]=function()local b,c,d=a(32)local e return(function(...)local f=c.Parent.Parent local g,h=d(f.PubTypes),d(f.Logging.logError)local i=function(i:string)local j={}j.type='SpecialKey'j.kind='OnChange'j.stage='observer'function j.apply(k,l:any,m:Instance,n:{g.Task})local o,p=pcall(m.GetPropertyChangedSignal,m,i)if not o then h('cannotConnectChange',nil,m.ClassName,i)elseif typeof(l)~='function'then h('invalidChangeHandler',nil,i)else table.insert(n,p:Connect(function()l((m::any)[i])end))end end return j end return i end)()end,[33]=function()local b,c,d=a(33)local e return(function(...)local f=c.Parent.Parent local g,h,i,j=d(f.PubTypes),d(f.Instances.applyInstanceProps),d(f.Instances.defaultProps),d(f.Logging.logError)local k=function(k:string)return function(l:g.PropertyTable):Instance local m,n=pcall(Instance.new,k)if not m then j('cannotCreateClass',nil,k)end local o=i[k]if o~=nil then for p,q in pairs(o)do n[p]=q end end h(l,n)return n end end return k end)()end,[34]=function()local b,c,d=a(34)local e return(function(...)local f=c.Parent.Parent local g,h=d(f.PubTypes),d(f.Instances.applyInstanceProps)local i=function(i:Instance)return function(j:g.PropertyTable):Instance h(j,i)return i end end return i end)()end,[35]=function()local b,c,d=a(35)local e return(function(...)local f=c.Parent.Parent local g,h=d(f.PubTypes),{}h.type='SpecialKey'h.kind='Cleanup'h.stage='observer'function h.apply(i,j:any,k:Instance,l:{g.Task})table.insert(l,j)end return h end)()end,[36]=function()local b,c,d=a(36)local e return(function(...)local f=c.Parent.Parent local g,h,i,j=d(f.State.Observer),d(f.PubTypes),d(f.Logging.logWarn),d(f.Utility.xtypeof)type Set<T> ={[T]:boolean}local k,l=false,{}l.type='SpecialKey'l.kind='Children'l.stage='descendants'function l.apply(m,n:any,o:Instance,p:{h.Task})local q:Set<Instance>,r:Set<Instance>,s:{[h.StateObject<any>]:()->()},t:{[h.StateObject<any>]:()->()},u,v:()->()={},{},{},{},false local w=function()if not u then return end u=false r,q=q,r t,s=s,t table.clear(q)table.clear(s)local function w(x:any,y:string?)local z=j(x)if z=='Instance'then q[x]=true if r[x]==nil then x.Parent=o else r[x]=nil end if k and y~=nil then x.Name=y end elseif z=='State'then local A=x:get(false)if A~=nil then w(A,y)end local B=t[x]if B==nil then B=g(x):onChange(v)else t[x]=nil end s[x]=B elseif z=='table'then for A,B in pairs(x)do local C,D:string?=(typeof(A))if C=='string'then D=A elseif C=='number'and y~=nil then D=y..'_'..A end w(B,D)end else i('unrecognisedChildType',z)end end if n~=nil then w(n)end for x in pairs(r)do x.Parent=nil end for x,y in pairs(t)do y()end end v=function()if not u then u=true task.defer(w)end end table.insert(p,function()n=nil u=true w()end)u=true w()end return l::h.SpecialKey end)()end,[38]=function()local b,c,d=a(38)local e return(function(...)local f=c.Parent.Parent local g,h=d(f.PubTypes),d(f.Dependencies.sharedState)local i=h.initialisedStack local j=function(j:g.Dependency)local k=h.dependencySet if k~=nil then local l=h.initialisedStackSize if l>0 then local m=i[l]if m[j]~=nil then return end end k[j]=true end end return j end)()end,[39]=function()local b,c,d=a(39)local e return(function(...)local f=c.Parent.Parent local g=d(f.PubTypes)type Set<T> ={[T]:any}type Descendant=(g.Dependent&g.Dependency)|g.Dependent local h=function(h:g.Dependency)local i:{[Descendant]:number},j:{[Descendant]:boolean},k:{Descendant},l,m={},{},{},0,1 for n in h.dependentSet do l+=1 k[l]=n j[n]=true end while m<=l do local n=k[m]local o=i[n]i[n]=if o==nil then 1 else o+1 if(n::any).dependentSet~=nil then for p in(n::any).dependentSet do l+=1 k[l]=p end end m+=1 end m=1 while m<=l do local n=k[m]local o=i[n]-1 i[n]=o if o==0 and j[n]and n:update()and(n::any).dependentSet~=nil then for p in(n::any).dependentSet do j[p]=true end end m+=1 end end return h end)()end,[40]=function()local b,c,d=a(40)local e return(function(...)local f=c.Parent.Parent local g=d(f.PubTypes)type Set<T> ={[T]:any}local h:{Set<g.Dependency>},i,j:Set<g.Dependency>?={},0 return{dependencySet=j,initialisedStack=h,initialisedStackSize=i}end)()end,[41]=function()local b,c,d=a(41)local e return(function(...)local f=c.Parent.Parent local g,h=d(f.PubTypes),d(f.Dependencies.sharedState)local i=h.initialisedStack local j=function(j:g.Dependency)local k=h.initialisedStackSize for l,m in ipairs(i)do if l>k then return end m[j]=true end end return j end)()end,[42]=function()local b,c,d=a(42)local e return(function(...)local f=c.Parent.Parent local g,h,i=d(f.PubTypes),d(f.Logging.parseError),d(f.Dependencies.sharedState)type Set<T> ={[T]:any}local j,k=i.initialisedStack,0 local l=function(l:Set<g.Dependency>,m:(...any)->any,...)local n=i.dependencySet i.dependencySet=l i.initialisedStackSize+=1 local o,p=(i.initialisedStackSize)if o>k then p={}j[o]=p k=o else p=j[o]table.clear(p)end local q=table.pack(xpcall(m,h,...))i.dependencySet=n i.initialisedStackSize-=1 return table.unpack(q,1,q.n)end return l end)()end,[44]=function()local b,c,d=a(44)local e return(function(...)local f={}function f.to(g:Color3):Vector3 local h,i,j=g.R*0.4122214708+g.G*0.5363325363+g.B*0.0514459929,g.R*0.2119034982+g.G*0.6806995451+g.B*0.1073969566,g.R*0.0883024619+g.G*0.2817188376+g.B*0.6299787005 local k,l,m=h^(0.3333333333333333),i^(0.3333333333333333),j^(0.3333333333333333)return Vector3.new(k*0.2104542553+l*0.793617785-m*0.0040720468,k*1.9779984951-l*2.428592205+m*0.4505937099,k*0.0259040371+l*0.7827717662-m*0.808675766)end function f.from(g:Vector3,h:boolean?):Color3 local i,j,k=g.X+g.Y*0.3963377774+g.Z*0.2158037573,g.X-g.Y*0.1055613458-g.Z*0.0638541728,g.X-g.Y*0.0894841775-g.Z*1.291485548 local l,m,n=i^3,j^3,k^3 local o,p,q=l*4.0767416621-m*3.3077115913+n*0.2309699292,l*-1.2684380046+m*2.6097574011-n*0.3413193965,l*-4.196086299999999E-3-m*0.7034186147+n*1.707614701 if not h then o=math.clamp(o,0,1)p=math.clamp(p,0,1)q=math.clamp(q,0,1)end return Color3.new(o,p,q)end return f end)()end,[46]=function()local b,c,d=a(46)local e return(function(...)local f=c.Parent.Parent local g,h=d(f.Colour.Oklab),d(f.PubTypes)local i=function(i:any,j:string)if j=='number'then local k=i::number return{k}elseif j=='CFrame'then local k,l=i:ToAxisAngle()return{i.X,i.Y,i.Z,k.X,k.Y,k.Z,l}elseif j=='Color3'then local k=g.to(i)return{k.X,k.Y,k.Z}elseif j=='ColorSequenceKeypoint'then local k=g.to(i.Value)return{k.X,k.Y,k.Z,i.Time}elseif j=='DateTime'then return{i.UnixTimestampMillis}elseif j=='NumberRange'then return{i.Min,i.Max}elseif j=='NumberSequenceKeypoint'then return{i.Value,i.Time,i.Envelope}elseif j=='PhysicalProperties'then return{i.Density,i.Friction,i.Elasticity,i.FrictionWeight,i.ElasticityWeight}elseif j=='Ray'then return{i.Origin.X,i.Origin.Y,i.Origin.Z,i.Direction.X,i.Direction.Y,i.Direction.Z}elseif j=='Rect'then return{i.Min.X,i.Min.Y,i.Max.X,i.Max.Y}elseif j=='Region3'then return{i.CFrame.X,i.CFrame.Y,i.CFrame.Z,i.Size.X,i.Size.Y,i.Size.Z}elseif j=='Region3int16'then return{i.Min.X,i.Min.Y,i.Min.Z,i.Max.X,i.Max.Y,i.Max.Z}elseif j=='UDim'then return{i.Scale,i.Offset}elseif j=='UDim2'then return{i.X.Scale,i.X.Offset,i.Y.Scale,i.Y.Offset}elseif j=='Vector2'then return{i.X,i.Y}elseif j=='Vector2int16'then return{i.X,i.Y}elseif j=='Vector3'then return{i.X,i.Y,i.Z}elseif j=='Vector3int16'then return{i.X,i.Y,i.Z}else return{}end end return i end)()end,[47]=function()local b,c,d=a(47)local e return(function(...)local f=function(f:number,g:number,h:number)if f==0 or h==0 then return 1,0,0,1 end local i,j,k,l if g>1 then local m,n=f*h,math.sqrt(g^2-1)local o,p=-0.5/n,-n-g local q,r=1/p,math.exp(m*p)local s=math.exp(m*q)i=(s*p-r*q)*o j=(r-s)*o/h k=(s-r)*o*h l=(r*p-s*q)*o elseif g==1 then local m=f*h local n=math.exp(-m)i=n*(1+m)j=n*f k=n*(-m*h)l=n*(1-m)else local m,n=f*h,math.sqrt(1-g^2)local o,p,q=1/n,n*m,math.exp(-m*g)local r,s=q*math.sin(p),q*math.cos(p)local t=r*o local u=t*g i=u+s j=t k=-(u*g+r*n)l=s-u end return i,j,k,l end return f end)()end,[48]=function()local b,c,d=a(48)local e return(function(...)local f=c.Parent.Parent local g,h=d(f.Colour.Oklab),d(f.PubTypes)local i=function(i:{number},j:string)if j=='number'then return i[1]elseif j=='CFrame'then return CFrame.new(i[1],i[2],i[3])*CFrame.fromAxisAngle(Vector3.new(i[4],i[5],i[6]).Unit,i[7])elseif j=='Color3'then return g.from(Vector3.new(i[1],i[2],i[3]),false)elseif j=='ColorSequenceKeypoint'then return ColorSequenceKeypoint.new(i[4],g.from(Vector3.new(i[1],i[2],i[3]),false))elseif j=='DateTime'then return DateTime.fromUnixTimestampMillis(i[1])elseif j=='NumberRange'then return NumberRange.new(i[1],i[2])elseif j=='NumberSequenceKeypoint'then return NumberSequenceKeypoint.new(i[2],i[1],i[3])elseif j=='PhysicalProperties'then return PhysicalProperties.new(i[1],i[2],i[3],i[4],i[5])elseif j=='Ray'then return Ray.new(Vector3.new(i[1],i[2],i[3]),Vector3.new(i[4],i[5],i[6]))elseif j=='Rect'then return Rect.new(i[1],i[2],i[3],i[4])elseif j=='Region3'then local k,l=Vector3.new(i[1],i[2],i[3]),Vector3.new(i[4]/2,i[5]/2,i[6]/2)return Region3.new(k-l,k+l)elseif j=='Region3int16'then return Region3int16.new(Vector3int16.new(i[1],i[2],i[3]),Vector3int16.new(i[4],i[5],i[6]))elseif j=='UDim'then return UDim.new(i[1],i[2])elseif j=='UDim2'then return UDim2.new(i[1],i[2],i[3],i[4])elseif j=='Vector2'then return Vector2.new(i[1],i[2])elseif j=='Vector2int16'then return Vector2int16.new(i[1],i[2])elseif j=='Vector3'then return Vector3.new(i[1],i[2],i[3])elseif j=='Vector3int16'then return Vector3int16.new(i[1],i[2],i[3])else return nil end end return i end)()end,[49]=function()local b,c,d=a(49)local e return(function(...)local f=c.Parent.Parent local g,h=d(f.Colour.Oklab),d(f.PubTypes)local i=function(i:any,j:any,k:number)local l=typeof(i)if typeof(j)==l then if l=='number'then local m,n=j::number,i::number return(m-n)*k+n elseif l=='CFrame'then local m,n=j::CFrame,i::CFrame return n:Lerp(m,k)elseif l=='Color3'then local m,n=j::Color3,i::Color3 local o,p=g.to(n),g.to(m)return g.from(o:Lerp(p,k),false)elseif l=='ColorSequenceKeypoint'then local m,n=j::ColorSequenceKeypoint,i::ColorSequenceKeypoint local o,p=g.to(n.Value),g.to(m.Value)return ColorSequenceKeypoint.new((m.Time-n.Time)*k+n.Time,g.from(o:Lerp(p,k),false))elseif l=='DateTime'then local m,n=j::DateTime,i::DateTime return DateTime.fromUnixTimestampMillis((m.UnixTimestampMillis-n.UnixTimestampMillis)*k+n.UnixTimestampMillis)elseif l=='NumberRange'then local m,n=j::NumberRange,i::NumberRange return NumberRange.new((m.Min-n.Min)*k+n.Min,(m.Max-n.Max)*k+n.Max)elseif l=='NumberSequenceKeypoint'then local m,n=j::NumberSequenceKeypoint,i::NumberSequenceKeypoint return NumberSequenceKeypoint.new((m.Time-n.Time)*k+n.Time,(m.Value-n.Value)*k+n.Value,(m.Envelope-n.Envelope)*k+n.Envelope)elseif l=='PhysicalProperties'then local m,n=j::PhysicalProperties,i::PhysicalProperties return PhysicalProperties.new((m.Density-n.Density)*k+n.Density,(m.Friction-n.Friction)*k+n.Friction,(m.Elasticity-n.Elasticity)*k+n.Elasticity,(m.FrictionWeight-n.FrictionWeight)*k+n.FrictionWeight,(m.ElasticityWeight-n.ElasticityWeight)*k+n.ElasticityWeight)elseif l=='Ray'then local m,n=j::Ray,i::Ray return Ray.new(n.Origin:Lerp(m.Origin,k),n.Direction:Lerp(m.Direction,k))elseif l=='Rect'then local m,n=j::Rect,i::Rect return Rect.new(n.Min:Lerp(m.Min,k),n.Max:Lerp(m.Max,k))elseif l=='Region3'then local m,n=j::Region3,i::Region3 local o,p=n.CFrame.Position:Lerp(m.CFrame.Position,k),n.Size:Lerp(m.Size,k)/2 return Region3.new(o-p,o+p)elseif l=='Region3int16'then local m,n=j::Region3int16,i::Region3int16 return Region3int16.new(Vector3int16.new((m.Min.X-n.Min.X)*k+n.Min.X,(m.Min.Y-n.Min.Y)*k+n.Min.Y,(m.Min.Z-n.Min.Z)*k+n.Min.Z),Vector3int16.new((m.Max.X-n.Max.X)*k+n.Max.X,(m.Max.Y-n.Max.Y)*k+n.Max.Y,(m.Max.Z-n.Max.Z)*k+n.Max.Z))elseif l=='UDim'then local m,n=j::UDim,i::UDim return UDim.new((m.Scale-n.Scale)*k+n.Scale,(m.Offset-n.Offset)*k+n.Offset)elseif l=='UDim2'then local m,n=j::UDim2,i::UDim2 return n:Lerp(m,k)elseif l=='Vector2'then local m,n=j::Vector2,i::Vector2 return n:Lerp(m,k)elseif l=='Vector2int16'then local m,n=j::Vector2int16,i::Vector2int16 return Vector2int16.new((m.X-n.X)*k+n.X,(m.Y-n.Y)*k+n.Y)elseif l=='Vector3'then local m,n=j::Vector3,i::Vector3 return n:Lerp(m,k)elseif l=='Vector3int16'then local m,n=j::Vector3int16,i::Vector3int16 return Vector3int16.new((m.X-n.X)*k+n.X,(m.Y-n.Y)*k+n.Y,(m.Z-n.Z)*k+n.Z)end end if k<0.5 then return i else return j end end return i end)()end,[50]=function()local b,c,d=a(50)local e return(function(...)local f=game:GetService'TweenService'local g=function(g:TweenInfo,h:number)local i,j,k,l,m,n=g.DelayTime,g.Time,g.Reverses,1+g.RepeatCount,g.EasingStyle,g.EasingDirection local o=i+j if k then o+=j end if h>=o*l then return 1 end local p=h%o if p<=i then return 0 end local q=(p-i)/j if q>1 then q=2-q end local r=f:GetValue(q,m,n)return r end return g end)()end,[51]=function()local b,c,d=a(51)local e return(function(...)local f,g=game:GetService'RunService',c.Parent.Parent local h,i,j,k,l=d(g.Types),d(g.Animation.getTweenRatio),d(g.Animation.lerpType),d(g.Dependencies.updateAll),{}type Set<T> ={[T]:any}type Tween=h.Tween<any>local m,n:Set<Tween> ={__mode='k'},{}setmetatable(n,m)function l.add(o:Tween)n[o]=true end function l.remove(o:Tween)n[o]=nil end local o=function()local o=os.clock()for p:Tween in pairs(n::any)do local q=o-p._currentTweenStartTime if q>p._currentTweenDuration then if p._currentTweenInfo.Reverses then p._currentValue=p._prevValue else p._currentValue=p._nextValue end p._currentlyAnimating=false k(p)l.remove(p)else local r=i(p._currentTweenInfo,q)local s=j(p._prevValue,p._nextValue,r)p._currentValue=s p._currentlyAnimating=true k(p)end end end f:BindToRenderStep('__FusionTweenScheduler',Enum.RenderPriority.First.Value,o)return l end)()end,[52]=function()local b,c,d=a(52)local e return(function(...)local f=c.Parent.Parent local g,h,i,j,k,l,m,n,o=d(f.PubTypes),d(f.Animation.TweenScheduler),d(f.Types),d(f.Dependencies.initDependency),d(f.Logging.logError),d(f.Logging.logErrorNonFatal),d(f.Dependencies.useDependency),d(f.Utility.xtypeof),{}local p,q={__index=o},{__mode='k'}function o.get(r,s:boolean?):any if s~=false then m(r)end return r._currentValue end function o.update(r):boolean local s=r._goalState:get(false)if s==r._nextValue and not r._currentlyAnimating then return false end local t=r._tweenInfo if r._tweenInfoIsState then t=t:get()end if typeof(t)~='TweenInfo'then l('mistypedTweenInfo',nil,typeof(t))return false end r._prevValue=r._currentValue r._nextValue=s r._currentTweenStartTime=os.clock()r._currentTweenInfo=t local u=t.DelayTime+t.Time if t.Reverses then u+=t.Time end u*=t.RepeatCount+1 r._currentTweenDuration=u h.add(r)return false end local r=function(r:g.StateObject<g.Animatable>,s:g.CanBeState<TweenInfo>?)local t=r:get(false)if s==nil then s=TweenInfo.new()end local u,v={[r]=true},n(s)=='State'if v then u[s]=true end local w=s if v then w=w:get()end if typeof(w)~='TweenInfo'then k('mistypedTweenInfo',nil,typeof(w))end local x=setmetatable({type='State',kind='Tween',dependencySet=u,dependentSet=setmetatable({},q),_goalState=r,_tweenInfo=s,_tweenInfoIsState=v,_prevValue=t,_nextValue=t,_currentValue=t,_currentTweenInfo=s,_currentTweenDuration=0,_currentTweenStartTime=0,_currentlyAnimating=false},p)j(x)r.dependentSet[x]=true return x end return r end)()end,[53]=function()local b,c,d=a(53)local e return(function(...)local f,g=game:GetService'RunService',c.Parent.Parent local h,i,j,k=d(g.Types),d(g.Animation.packType),d(g.Animation.springCoefficients),d(g.Dependencies.updateAll)type Set<T> ={[T]:any}type Spring=h.Spring<any>local l,m,n:Set<Spring>,o={},0.0001,{},os.clock()function l.add(p:Spring)p._lastSchedule=o p._startDisplacements={}p._startVelocities={}for q,r in ipairs(p._springGoals)do p._startDisplacements[q]=p._springPositions[q]-r p._startVelocities[q]=p._springVelocities[q]end n[p]=true end function l.remove(p:Spring)n[p]=nil end local p=function()local p:Set<Spring> ={}o=os.clock()for q in pairs(n)do local r,s,t,u=j(o-q._lastSchedule,q._currentDamping,q._currentSpeed)local v,w,x,y,z=q._springPositions,q._springVelocities,q._startDisplacements,q._startVelocities,false for A,B in ipairs(q._springGoals)do local C,D=x[A],y[A]local E,F=C*r+D*s,C*t+D*u if math.abs(E)>m or math.abs(F)>m then z=true end v[A]=E+B w[A]=F end if not z then p[q]=true end end for q in pairs(n)do q._currentValue=i(q._springPositions,q._currentType)k(q)end for q in pairs(p)do n[q]=nil end end f:BindToRenderStep('__FusionSpringScheduler',Enum.RenderPriority.First.Value,p)return l end)()end,[54]=function()local b,c,d=a(54)local e return(function(...)local f=c.Parent.Parent local g,h,i,j,k,l,m,n,o,p,q,r=d(f.PubTypes),d(f.Animation.SpringScheduler),d(f.Types),d(f.Dependencies.initDependency),d(f.Logging.logError),d(f.Logging.logErrorNonFatal),d(f.Animation.unpackType),d(f.State.unwrap),d(f.Dependencies.updateAll),d(f.Dependencies.useDependency),d(f.Utility.xtypeof),{}local s,t={__index=r},{__mode='k'}function r.get(u,v:boolean?):any if v~=false then p(u)end return u._currentValue end function r.setPosition(u,v:g.Animatable)local w=typeof(v)if w~=u._currentType then k('springTypeMismatch',nil,w,u._currentType)end u._springPositions=m(v,w)u._currentValue=v h.add(u)o(u)end function r.setVelocity(u,v:g.Animatable)local w=typeof(v)if w~=u._currentType then k('springTypeMismatch',nil,w,u._currentType)end u._springVelocities=m(v,w)h.add(u)end function r.addVelocity(u,v:g.Animatable)local w=typeof(v)if w~=u._currentType then k('springTypeMismatch',nil,w,u._currentType)end local x=m(v,w)for y,z in ipairs(x)do u._springVelocities[y]+=z end h.add(u)end function r.update(u):boolean local v=u._goalState:get(false)if v==u._goalValue then local w=n(u._damping)if typeof(w)~='number'then l('mistypedSpringDamping',nil,typeof(w))elseif w<0 then l('invalidSpringDamping',nil,w)else u._currentDamping=w end local x=n(u._speed)if typeof(x)~='number'then l('mistypedSpringSpeed',nil,typeof(x))elseif x<0 then l('invalidSpringSpeed',nil,x)else u._currentSpeed=x end return false else u._goalValue=v local w,x=u._currentType,typeof(v)u._currentType=x local y=m(v,x)local z=#y u._springGoals=y if x~=w then u._currentValue=u._goalValue local A,B=table.create(z,0),table.create(z,0)for C,D in ipairs(y)do A[C]=D end u._springPositions=A u._springVelocities=B h.remove(u)return true elseif z==0 then u._currentValue=u._goalValue return true else h.add(u)return false end end end local u=function(u:g.Value<T>,v:g.CanBeState<number>?,w:g.CanBeState<number>?)if v==nil then v=10 end if w==nil then w=1 end local x={[u]=true}if q(v)=='State'then x[v]=true end if q(w)=='State'then x[w]=true end local y=setmetatable({type='State',kind='Spring',dependencySet=x,dependentSet=setmetatable({},t),_speed=v,_damping=w,_goalState=u,_goalValue=nil,_currentType=nil,_currentValue=nil,_currentSpeed=n(v),_currentDamping=n(w),_springPositions=nil,_springGoals=nil,_springVelocities=nil},s)j(y)u.dependentSet[y]=true y:update()return y end return u end)()end},{{1,2,{'Fusion'},{{20,1,{'Logging'},{{24,2,{'logErrorNonFatal'}},{21,2,{'parseError'}},{23,2,{'logWarn'}},{25,2,{'logError'}},{22,2,{'messages'}}}},{37,1,{'Dependencies'},{{38,2,{'useDependency'}},{42,2,{'captureDependencies'}},{41,2,{'initDependency'}},{40,2,{'sharedState'}},{39,2,{'updateAll'}}}},{11,1,{'State'},{{12,2,{'unwrap'}},{17,2,{'ForKeys'}},{18,2,{'Computed'}},{13,2,{'Value'}},{15,2,{'ForValues'}},{14,2,{'Observer'}},{16,2,{'ForPairs'}}}},{26,1,{'Instances'},{{28,2,{'applyInstanceProps'}},{33,2,{'New'}},{27,2,{'defaultProps'}},{36,2,{'Children'}},{31,2,{'OnEvent'}},{35,2,{'Cleanup'}},{32,2,{'OnChange'}},{34,2,{'Hydrate'}},{30,2,{'Out'}},{29,2,{'Ref'}}}},{10,2,{'Types'}},{45,1,{'Animation'},{{48,2,{'packType'}},{54,2,{'Spring'}},{51,2,{'TweenScheduler'}},{46,2,{'unpackType'}},{50,2,{'getTweenRatio'}},{53,2,{'SpringScheduler'}},{52,2,{'Tween'}},{49,2,{'lerpType'}},{47,2,{'springCoefficients'}}}},{43,1,{'Colour'},{{44,2,{'Oklab'}}}},{19,2,{'PubTypes'}},{2,1,{'Utility'},{{3,2,{'xtypeof'}},{9,2,{'None'}},{5,2,{'needsDestruction'}},{8,2,{'cleanup'}},{7,2,{'doNothing'}},{4,2,{'restrictRead'}},{6,2,{'isSimilar'}}}}}}},'0.4.1','WaxRuntime',string,task,setmetatable,error,next,table,unpack,coroutine,script,type,require,pcall,tostring,tonumber,_VERSION local v,w,x,y,z,A,B=k.insert,k.remove,k.freeze or function(v)return v end,m.wrap,f.sub,f.match,f.gmatch if t and z(t,1,4)=='Lune'then local C,D=q(p,'@lune/task')if C and D then g=D end end local C=g and g.defer local D,E,F,G,H,I,J,K,L=C or function(D,...)y(D)(...)end,{[1]='Folder',[2]='ModuleScript',[3]='Script',[4]='LocalScript',[5]='StringValue'},{},{},{},{},{},{},{}local M,N={GetFullName={{},function(M)local N,O=M.Name,M.Parent while O do N=O.Name..'.'..N O=O.Parent end return N end},GetChildren={{},function(M)local N={}for O in j,L[M]do v(N,O)end return N end},GetDescendants={{},function(M)local N={}for O in j,L[M]do v(N,O)for P,Q in j,O:GetDescendants()do v(N,Q)end end return N end},FindFirstChild={{'string','boolean?'},function(M,N,O)local P=L[M]for Q in j,P do if Q.Name==N then return Q end end if O then for Q in j,P do return Q:FindFirstChild(N,true)end end end},FindFirstAncestor={{'string'},function(M,N)local O=M.Parent while O do if O.Name==N then return O end O=O.Parent end end},WaitForChild={{'string','number?'},function(M,N)return M:FindFirstChild(N)end}},{}for O,P in j,M do local Q,R,S=P[1],P[2],{}for T,U in j,Q do local V,W=A(U,'^([^%?]+)(%??)')S[T]={V,W}end N[O]=function(T,...)if not L[T]then i("Expected ':' not '.' calling member function "..O,2)end local U={...}for V,W in j,S do local X=U[V]local Y,Z,_=o(X),W[1],W[2]if X==nil and not _ then i('Argument '..X..' missing or nil',3)end if Z~='any'and Y~=Z and not(Y=='nil'and _)then i('Argument '..V..' expects type "'..Z..'", got "'..Y..'"',2)end end return R(T,...)end end local O=function(O,P,Q)local R,S,T,U,V,W=h({},{__mode='k'}),function(R)i(R..' is not a valid (virtual) member of '..O..' "'..P..'"',3)end,function(R)i('Unable to assign (virtual) property '..R..'. Property is read only',3)end,{},{}V.__metatable=false V.__index=function(X,Y)if Y=='ClassName'then return O elseif Y=='Name'then return P elseif Y=='Parent'then return Q elseif O=='StringValue'and Y=='Value'then return W else local Z=N[Y]if Z then return Z end end for Z in j,R do if Z.Name==Y then return Z end end S(Y)end V.__newindex=function(X,Y,Z)if Y=='ClassName'then T(Y)elseif Y=='Name'then P=Z elseif Y=='Parent'then if Z==U then return end if Q~=nil then L[Q][U]=nil end Q=Z if Z~=nil then L[Z][U]=true end elseif O=='StringValue'and Y=='Value'then W=Z else S(Y)end end V.__tostring=function()return P end h(U,V)L[U]=R if Q~=nil then L[Q][U]=true end return U end local function P(Q,R)local S,T,U,V=Q[1],Q[2],Q[3],Q[4]local W=E[T]local X=U and w(U,1)or W local Y=O(W,X,R)F[S]=Y if U then for Z,_ in j,U do Y[Z]=_ end end if V then for Z,_ in j,V do P(_,Y)end end return Y end local Q=O('Folder','['..e..']')for R,S in j,c do P(S,Q)end for R,S in j,b do local T=F[R]G[T]=S H[T]=R local U=T.ClassName if U=='LocalScript'or U=='Script'then v(J,T)end end local R=function(R)local S,T=R.ClassName,I[R]if T and S=='ModuleScript'then return l(T)end local U,V=G[R],function(U)U=r(U)local V,W,X=R:GetFullName(),A(U,'[^:]+:(%d+): (.+)')if not W or not u then return V..':*: '..(X or U)end W=s(W)local Y=H[R]local Z=u[Y]local _=W-Z+1 if _<0 then _='?'end return V..':'.._..': '..X end if S=='LocalScript'or S=='Script'then local W,X=q(U)if not W then i(V(X),0)end else local W={q(U)}local X=w(W,1)if not X then local Y=w(W,1)i(V(Y),0)end I[R]=W return l(W)end end function a(S)local T,U,V=F[S],function(T,...)local U={q(T,...)}local V=w(U,1)if not V then i(U[1],3)end return l(U)end,x(h({},{__index=K,__newindex=function(T,U,V)K[U]=V end,__len=function()return#K end,__iter=function()return j,K end}))local aa,ab,ac=x{version=d,envname=e,shared=V,script=n,require=p},T,function(W,...)local X,Y,Z=o(W),'Attempted to call require with a non-ModuleScript','Attempted to call require with self'if X=='table'and L[W]then if W.ClassName~='ModuleScript'then i(Y,2)elseif W==T then i(Z,2)end return R(W)elseif X=='string'and z(W,1,1)~='@'then if#W==0 then i('Attempted to call require with empty string',2)end local _=T if z(W,1,1)=='/'then _=Q elseif z(W,1,2)=='./'then W=z(W,3)end local aa for ab in B(W,'([^/]*)/?')do local ac=ab if ab=='..'then ac='Parent'end if ac~=''then local ad=_:FindFirstChild(ac)if not ad then local ae=_.Parent if ae then ad=ae:FindFirstChild(ac)end end if ad then _=ad elseif ab~=aa and ab~='init'and ab~='init.server'and ab~='init.client'then i('Virtual script path "'..W..'" not found',2)end end aa=ab end if _.ClassName~='ModuleScript'then i(Y,2)elseif _==T then i(Z,2)end return R(_)end return U(p,W,...)end return aa,ab,ac end for aa,ab in j,J do D(R,ab)end return R(Q:GetChildren()[1])
